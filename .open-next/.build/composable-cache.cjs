globalThis.disableIncrementalCache = false;globalThis.disableDynamoDBCache = false;globalThis.isNextAfter15 = true;globalThis.openNextDebug = false;globalThis.openNextVersion = "3.7.7";
var f=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var x=(e,t)=>{for(var a in t)f(e,a,{get:t[a],enumerable:!0})},v=(e,t,a,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of b(t))!T.call(e,r)&&r!==a&&f(e,r,{get:()=>t[r],enumerable:!(o=p(t,r))||o.enumerable});return e};var N=e=>v(f({},"__esModule",{value:!0}),e);var R={};x(R,{default:()=>w});module.exports=N(R);function i(...e){globalThis.openNextDebug&&console.log(...e)}function C(e){return typeof e=="string"?e:JSON.stringify({tag:e.tag,path:e.path})}async function l(e){let t=globalThis.__openNextAls.getStore();if(i("Writing tags",e,t),!t||globalThis.openNextConfig.dangerous?.disableTagCache)return;let a=e.filter(o=>{let r=C(o),n=!t.writtenTags.has(r);return n&&t.writtenTags.add(r),n});a.length!==0&&await globalThis.tagCache.writeTags(a)}var d=require("node:stream");function m(e,t){let a=e.getReader(),o=[];return new Promise((r,n)=>{function s(){a.read().then(({done:u,value:h})=>{if(u){r(Buffer.concat(o).toString(t?"base64":"utf8"));return}o.push(h),s()}).catch(n)}s()})}function g(e,t){return d.Readable.toWeb(d.Readable.from(Buffer.from(e,t?"base64":"utf8")))}var c=new Map,w={async get(e){try{if(c.has(e)){let a=c.get(e);if(a)return a.then(o=>({...o,value:g(o.value)}))}let t=await globalThis.incrementalCache.get(e,"composable");if(!t?.value?.value)return;if(i("composable cache result",t),globalThis.tagCache.mode==="nextMode"&&t.value.tags.length>0){if(t.shouldBypassTagCache?!1:await globalThis.tagCache.hasBeenRevalidated(t.value.tags,t.lastModified))return}else if((globalThis.tagCache.mode==="original"||globalThis.tagCache.mode===void 0)&&(t.shouldBypassTagCache?!1:await globalThis.tagCache.getLastModified(e,t.lastModified)===-1))return;return{...t.value,value:g(t.value.value)}}catch{i("Cannot read composable cache entry");return}},async set(e,t){let a=t.then(async r=>({...r,value:await m(r.value)}));c.set(e,a);let o=await a.finally(()=>{c.delete(e)});if(await globalThis.incrementalCache.set(e,{...o,value:o.value},"composable"),globalThis.tagCache.mode==="original"){let r=await globalThis.tagCache.getByPath(e),n=o.tags.filter(s=>!r.includes(s));n.length>0&&await l(n.map(s=>({tag:s,path:e})))}},async refreshTags(){},async getExpiration(...e){return globalThis.tagCache.mode==="nextMode"?globalThis.tagCache.getLastRevalidated(e):0},async expireTags(...e){if(globalThis.tagCache.mode==="nextMode")return l(e);let t=globalThis.tagCache,a=Date.now(),o=await Promise.all(e.map(async n=>(await t.getByTag(n)).map(u=>({path:u,tag:n,revalidatedAt:a})))),r=new Set;for(let n of o.flat())r.add(n);await l(Array.from(r))},async receiveExpiredTags(...e){}};
